// Enhanced form validation with better UX\n\n/**\n * Advanced Form Validator\n */\nclass FormValidator {\n    constructor(formElement, options = {}) {\n        this.form = formElement;\n        this.options = {\n            validateOnBlur: true,\n            validateOnInput: true,\n            showProgress: true,\n            realTimeValidation: true,\n            ...options\n        };\n        \n        this.fields = new Map();\n        this.errors = new Map();\n        this.isValid = false;\n        \n        this.init();\n    }\n    \n    init() {\n        this.setupFields();\n        this.setupEventListeners();\n        this.createProgressBar();\n    }\n    \n    setupFields() {\n        const inputs = this.form.querySelectorAll('input, select, textarea');\n        \n        inputs.forEach(input => {\n            const rules = this.parseValidationRules(input);\n            this.fields.set(input, {\n                element: input,\n                rules: rules,\n                isValid: false,\n                hasBeenValidated: false\n            });\n            \n            this.setupFieldValidation(input);\n        });\n    }\n    \n    parseValidationRules(input) {\n        const rules = [];\n        \n        // Required\n        if (input.hasAttribute('required')) {\n            rules.push({\n                name: 'required',\n                message: `${this.getFieldLabel(input)} is required`,\n                validate: (value) => value.trim() !== ''\n            });\n        }\n        \n        // Type-specific validations\n        switch (input.type) {\n            case 'email':\n                rules.push({\n                    name: 'email',\n                    message: 'Please enter a valid email address',\n                    validate: (value) => !value || /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)\n                });\n                break;\n                \n            case 'number':\n                if (input.hasAttribute('min')) {\n                    const min = parseFloat(input.getAttribute('min'));\n                    rules.push({\n                        name: 'min',\n                        message: `Value must be at least ${min}`,\n                        validate: (value) => !value || parseFloat(value) >= min\n                    });\n                }\n                \n                if (input.hasAttribute('max')) {\n                    const max = parseFloat(input.getAttribute('max'));\n                    rules.push({\n                        name: 'max',\n                        message: `Value must not exceed ${max}`,\n                        validate: (value) => !value || parseFloat(value) <= max\n                    });\n                }\n                break;\n                \n            case 'password':\n                rules.push({\n                    name: 'minLength',\n                    message: 'Password must be at least 6 characters long',\n                    validate: (value) => !value || value.length >= 6\n                });\n                break;\n        }\n        \n        // Custom validations\n        const customRules = input.getAttribute('data-validate');\n        if (customRules) {\n            this.parseCustomRules(customRules, rules);\n        }\n        \n        return rules;\n    }\n    \n    parseCustomRules(customRules, rules) {\n        const ruleStrings = customRules.split('|');\n        \n        ruleStrings.forEach(ruleString => {\n            const [ruleName, ruleValue] = ruleString.split(':');\n            \n            switch (ruleName) {\n                case 'minLength':\n                    rules.push({\n                        name: 'minLength',\n                        message: `Must be at least ${ruleValue} characters`,\n                        validate: (value) => !value || value.length >= parseInt(ruleValue)\n                    });\n                    break;\n                    \n                case 'maxLength':\n                    rules.push({\n                        name: 'maxLength',\n                        message: `Must not exceed ${ruleValue} characters`,\n                        validate: (value) => !value || value.length <= parseInt(ruleValue)\n                    });\n                    break;\n                    \n                case 'pattern':\n                    rules.push({\n                        name: 'pattern',\n                        message: 'Invalid format',\n                        validate: (value) => !value || new RegExp(ruleValue).test(value)\n                    });\n                    break;\n                    \n                case 'numeric':\n                    rules.push({\n                        name: 'numeric',\n                        message: 'Must be a valid number',\n                        validate: (value) => !value || !isNaN(value)\n                    });\n                    break;\n                    \n                case 'positive':\n                    rules.push({\n                        name: 'positive',\n                        message: 'Must be a positive number',\n                        validate: (value) => !value || parseFloat(value) > 0\n                    });\n                    break;\n            }\n        });\n    }\n    \n    setupFieldValidation(input) {\n        const wrapper = input.closest('.form-group');\n        if (!wrapper) return;\n        \n        // Create or get message container\n        let messageContainer = wrapper.querySelector('.field-message');\n        if (!messageContainer) {\n            messageContainer = document.createElement('div');\n            messageContainer.className = 'field-message';\n            messageContainer.innerHTML = '<i class=\"fas fa-exclamation-circle\"></i><span></span>';\n            wrapper.appendChild(messageContainer);\n        }\n        \n        // Validation on blur\n        if (this.options.validateOnBlur) {\n            input.addEventListener('blur', () => {\n                this.validateField(input);\n                this.updateProgress();\n            });\n        }\n        \n        // Real-time validation on input (with debounce)\n        if (this.options.validateOnInput) {\n            let timeout;\n            input.addEventListener('input', () => {\n                clearTimeout(timeout);\n                timeout = setTimeout(() => {\n                    if (this.fields.get(input)?.hasBeenValidated) {\n                        this.validateField(input);\n                        this.updateProgress();\n                    }\n                }, 300);\n            });\n        }\n        \n        // Focus handling\n        input.addEventListener('focus', () => {\n            wrapper.classList.remove('error', 'valid');\n            this.hideFieldMessage(input);\n        });\n    }\n    \n    validateField(input) {\n        const fieldData = this.fields.get(input);\n        if (!fieldData) return false;\n        \n        const value = input.value.trim();\n        const wrapper = input.closest('.form-group');\n        \n        fieldData.hasBeenValidated = true;\n        \n        // Run all validation rules\n        for (const rule of fieldData.rules) {\n            if (!rule.validate(value)) {\n                this.showFieldError(input, rule.message);\n                fieldData.isValid = false;\n                return false;\n            }\n        }\n        \n        // Field is valid\n        this.showFieldSuccess(input);\n        fieldData.isValid = true;\n        return true;\n    }\n    \n    showFieldError(input, message) {\n        const wrapper = input.closest('.form-group');\n        const messageContainer = wrapper.querySelector('.field-message');\n        const messageText = messageContainer.querySelector('span');\n        \n        wrapper.classList.remove('valid');\n        wrapper.classList.add('error');\n        \n        input.setAttribute('aria-invalid', 'true');\n        \n        messageText.textContent = message;\n        messageContainer.classList.remove('success');\n        messageContainer.classList.add('error', 'show');\n        \n        this.errors.set(input, message);\n    }\n    \n    showFieldSuccess(input) {\n        const wrapper = input.closest('.form-group');\n        const messageContainer = wrapper.querySelector('.field-message');\n        const messageText = messageContainer.querySelector('span');\n        const icon = messageContainer.querySelector('i');\n        \n        wrapper.classList.remove('error');\n        wrapper.classList.add('valid');\n        \n        input.setAttribute('aria-invalid', 'false');\n        \n        messageText.textContent = 'Looks good!';\n        icon.className = 'fas fa-check-circle';\n        messageContainer.classList.remove('error');\n        messageContainer.classList.add('success', 'show');\n        \n        this.errors.delete(input);\n        \n        // Hide success message after 2 seconds\n        setTimeout(() => {\n            this.hideFieldMessage(input);\n        }, 2000);\n    }\n    \n    hideFieldMessage(input) {\n        const wrapper = input.closest('.form-group');\n        const messageContainer = wrapper.querySelector('.field-message');\n        \n        if (messageContainer) {\n            messageContainer.classList.remove('show');\n        }\n    }\n    \n    validateForm() {\n        let isFormValid = true;\n        \n        this.fields.forEach((fieldData, input) => {\n            if (!this.validateField(input)) {\n                isFormValid = false;\n            }\n        });\n        \n        this.isValid = isFormValid;\n        this.updateProgress();\n        \n        return isFormValid;\n    }\n    \n    createProgressBar() {\n        if (!this.options.showProgress) return;\n        \n        const existingProgress = this.form.querySelector('.form-progress');\n        if (existingProgress) return;\n        \n        const progressContainer = document.createElement('div');\n        progressContainer.className = 'form-progress';\n        progressContainer.innerHTML = '<div class=\"form-progress-bar\"></div>';\n        \n        const firstFormGroup = this.form.querySelector('.form-group');\n        if (firstFormGroup) {\n            firstFormGroup.parentNode.insertBefore(progressContainer, firstFormGroup);\n        }\n    }\n    \n    updateProgress() {\n        const progressBar = this.form.querySelector('.form-progress-bar');\n        if (!progressBar) return;\n        \n        const totalFields = this.fields.size;\n        const validFields = Array.from(this.fields.values()).filter(field => field.isValid).length;\n        const progress = totalFields > 0 ? (validFields / totalFields) * 100 : 0;\n        \n        progressBar.style.width = `${progress}%`;\n        \n        // Update color based on progress\n        if (progress === 100) {\n            progressBar.style.background = '#4CAF50';\n        } else if (progress > 50) {\n            progressBar.style.background = 'linear-gradient(90deg, #16808D, #2196F3)';\n        } else {\n            progressBar.style.background = '#FF9800';\n        }\n    }\n    \n    getFieldLabel(input) {\n        const label = this.form.querySelector(`label[for=\"${input.id}\"]`);\n        return label ? label.textContent.replace(/[^a-zA-Z\\s]/g, '').trim() : input.name || 'Field';\n    }\n    \n    reset() {\n        this.fields.forEach((fieldData, input) => {\n            fieldData.isValid = false;\n            fieldData.hasBeenValidated = false;\n            \n            const wrapper = input.closest('.form-group');\n            wrapper.classList.remove('error', 'valid');\n            \n            input.setAttribute('aria-invalid', 'false');\n            this.hideFieldMessage(input);\n        });\n        \n        this.errors.clear();\n        this.isValid = false;\n        this.updateProgress();\n    }\n    \n    getErrors() {\n        return Array.from(this.errors.values());\n    }\n    \n    getFirstError() {\n        return this.errors.values().next().value;\n    }\n    \n    focusFirstError() {\n        const firstErrorField = this.errors.keys().next().value;\n        if (firstErrorField) {\n            firstErrorField.focus();\n            firstErrorField.scrollIntoView({ behavior: 'smooth', block: 'center' });\n        }\n    }\n}\n\n/**\n * Enhanced Submit Button Handler\n */\nclass SubmitButtonHandler {\n    constructor(button, options = {}) {\n        this.button = button;\n        this.options = {\n            loadingText: 'Processing...',\n            successText: 'Success!',\n            successDuration: 2000,\n            ...options\n        };\n        \n        this.originalText = button.innerHTML;\n        this.isLoading = false;\n    }\n    \n    setLoading(loading = true) {\n        this.isLoading = loading;\n        \n        if (loading) {\n            this.button.disabled = true;\n            this.button.classList.add('loading');\n            this.button.innerHTML = `<i class=\"fas fa-spinner fa-spin\"></i> ${this.options.loadingText}`;\n        } else {\n            this.button.disabled = false;\n            this.button.classList.remove('loading');\n            this.button.innerHTML = this.originalText;\n        }\n    }\n    \n    setSuccess(duration = this.options.successDuration) {\n        this.button.classList.add('success');\n        this.button.innerHTML = `<i class=\"fas fa-check\"></i> ${this.options.successText}`;\n        \n        setTimeout(() => {\n            this.button.classList.remove('success');\n            this.setLoading(false);\n        }, duration);\n    }\n    \n    setError(errorText = 'Error occurred', duration = 3000) {\n        this.button.classList.add('error');\n        this.button.innerHTML = `<i class=\"fas fa-exclamation-circle\"></i> ${errorText}`;\n        \n        setTimeout(() => {\n            this.button.classList.remove('error');\n            this.setLoading(false);\n        }, duration);\n    }\n    \n    reset() {\n        this.button.classList.remove('loading', 'success', 'error');\n        this.button.disabled = false;\n        this.button.innerHTML = this.originalText;\n        this.isLoading = false;\n    }\n}\n\n// Export for use in other modules\nexport { FormValidator, SubmitButtonHandler };\n\n// Auto-initialize forms with data-validate attribute\ndocument.addEventListener('DOMContentLoaded', () => {\n    const forms = document.querySelectorAll('form[data-validate]');\n    forms.forEach(form => {\n        new FormValidator(form);\n    });\n});